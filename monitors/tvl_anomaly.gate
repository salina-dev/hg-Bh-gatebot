// TVL Anomaly (draft) â€“ monitors large balance drops in selected pools over a block window

use Call, Aggregate, PercentageDiff, Len, Range from hexagate;

// Configure in UI:
// - pairFactory: Arena/DEX factory to enumerate pairs
// - topN: how many pairs to scan (use a modest cap to control cost)
// - numBlocks: approximate time window in blocks (e.g., ~1800 for ~1h on Avalanche)
// - drop thresholds
source pairFactory: address = 0xF16784dcAf838a3e16bEF7711a62D12413c39BD1; // ArenaFactory
source topN: integer = 50;                   // scan first N pairs
source numBlocks: integer = 1800;            // ~1h on Avalanche
source dropThreshold: integer = 10;        // 10% drop (standard)
source criticalDropThreshold: integer = 40; // 40% drop (page immediately)
source smallDropThreshold: integer = 10;    // count pairs with >=10% drop
source minPairsDropping: integer = 3;       // if >=3 pairs drop, alert (blast radius)

// Enumerate pairs from factory
source numPairs: integer = Call {
  contract: pairFactory,
  signature: "function allPairsLength() view returns (uint256)"
};

source pairs: list<address> = [
  Call {
    contract: pairFactory,
    signature: "function allPairs(uint256) view returns (address)",
    params: tuple(i)
  }
  for i in Range { start: 0, stop: topN }
];

// For each pair, read token0/token1
source token0s: list<address> = [
  Call { contract: p, signature: "function token0() view returns (address)" }
  for p in pairs
];

source token1s: list<address> = [
  Call { contract: p, signature: "function token1() view returns (address)" }
  for p in pairs
];

// Build (token, pair) tuples for both legs
source monitoredPairsA: list<tuple<address, address>> = [
  tuple(token0s[i], pairs[i])
  for i in Range { start: 0, stop: topN }
];

source monitoredPairsB: list<tuple<address, address>> = [
  tuple(token1s[i], pairs[i])
  for i in Range { start: 0, stop: topN }
];

// Aggregate token balances for each (token, pair) over numBlocks
source balancesSeriesA: list<list<integer>> = [
  Aggregate {
    source: Call {
      contract: pair[0],
      signature: "function balanceOf(address) returns (uint256)",
      params: tuple(pair[1])
    },
    blocks: numBlocks
  }
  for pair in monitoredPairsA
];

source balancesSeriesB: list<list<integer>> = [
  Aggregate {
    source: Call {
      contract: pair[0],
      signature: "function balanceOf(address) returns (uint256)",
      params: tuple(pair[1])
    },
    blocks: numBlocks
  }
  for pair in monitoredPairsB
];

// First and last samples per series
source firstBalancesA: list<integer> = [ series[0] for series in balancesSeriesA ];
source lastBalancesA: list<integer> = [ series[numBlocks - 1] for series in balancesSeriesA ];
source firstBalancesB: list<integer> = [ series[0] for series in balancesSeriesB ];
source lastBalancesB: list<integer> = [ series[numBlocks - 1] for series in balancesSeriesB ];

// Percentage difference per pair
source percentageDropsA: list<integer> = [
  PercentageDiff { before: firstBalancesA[i], after: lastBalancesA[i] }
  for i in Range { start: 0, stop: topN }
];

source percentageDropsB: list<integer> = [
  PercentageDiff { before: firstBalancesB[i], after: lastBalancesB[i] }
  for i in Range { start: 0, stop: topN }
];

// Indices where direction is a drop (last < first)
source dropIndicesA: list<integer> = [
  i
  for i in Range { start: 0, stop: topN }
  if lastBalancesA[i] < firstBalancesA[i]
];

source dropIndicesB: list<integer> = [
  i
  for i in Range { start: 0, stop: topN }
  if lastBalancesB[i] < firstBalancesB[i]
];

// Pairs with drop exceeding thresholds
source anomalousPairsA: list<tuple<address, address>> = [
  monitoredPairsA[i]
  for i in dropIndicesA
  if percentageDropsA[i] >= dropThreshold
];

source anomalousPairsB: list<tuple<address, address>> = [
  monitoredPairsB[i]
  for i in dropIndicesB
  if percentageDropsB[i] >= dropThreshold
];

rule {
  description: "TVL anomaly: large drop detected for pairs $anomalousPairsA and $anomalousPairsB",
  condition: (Len { sequence: anomalousPairsA } + Len { sequence: anomalousPairsB }) == 0
};

// Critical drops (very large single-pair moves)
source criticalPairsA: list<tuple<address, address>> = [
  monitoredPairsA[i]
  for i in dropIndicesA
  if percentageDropsA[i] >= criticalDropThreshold
];

source criticalPairsB: list<tuple<address, address>> = [
  monitoredPairsB[i]
  for i in dropIndicesB
  if percentageDropsB[i] >= criticalDropThreshold
];

rule {
  description: "CRITICAL TVL drop (>=${criticalDropThreshold}%): $criticalPairsA $criticalPairsB",
  condition: (Len { sequence: criticalPairsA } + Len { sequence: criticalPairsB }) == 0
};

// Many small/medium drops in parallel (blast-radius signal)
source smallDropPairsA: list<tuple<address, address>> = [
  monitoredPairsA[i]
  for i in dropIndicesA
  if percentageDropsA[i] >= smallDropThreshold
];

source smallDropPairsB: list<tuple<address, address>> = [
  monitoredPairsB[i]
  for i in dropIndicesB
  if percentageDropsB[i] >= smallDropThreshold
];

rule {
  description: "Multiple pairs dropped >=${smallDropThreshold}%: count=${Len { sequence: smallDropPairsA } + Len { sequence: smallDropPairsB }}",
  condition: (Len { sequence: smallDropPairsA } + Len { sequence: smallDropPairsB }) < minPairsDropping
};
