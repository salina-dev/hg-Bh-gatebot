// TVL Anomaly â€“ monitors large balance drops in selected pools over a block window

use Call, Aggregate, PercentageDiff, Len, Range from hexagate;

source pairFactory: address = 0xF16784dcAf838a3e16bEF7711a62D12413c39BD1; // ArenaFactory
source topN: integer = 50;                   // how many pairs to scan (scan first N pairs)
source numBlocks: integer = 1800;            // ~1h on Avalanche
source dropThreshold: integer = 10;        // 10% drop

// Enumerate pairs from factory
source numPairs: integer = Call {
  contract: pairFactory,
  signature: "function allPairsLength() view returns (uint256)"
};

source pairs: list<address> = [
  Call {
    contract: pairFactory,
    signature: "function allPairs(uint256) view returns (address)",
    params: tuple(i)
  }
  for i in Range { start: 0, stop: topN }
];

// For each pair, read token0/token1
source token0s: list<address> = [
  Call { contract: p, signature: "function token0() view returns (address)" }
  for p in pairs
];

source token1s: list<address> = [
  Call { contract: p, signature: "function token1() view returns (address)" }
  for p in pairs
];

// Build (token, pair) tuples for both legs
source monitoredPairsA: list<tuple<address, address>> = [
  tuple(token0s[i], pairs[i])
  for i in Range { start: 0, stop: topN }
];

source monitoredPairsB: list<tuple<address, address>> = [
  tuple(token1s[i], pairs[i])
  for i in Range { start: 0, stop: topN }
];

// Aggregate token balances for each (token, pair) over numBlocks
source balancesSeriesA: list<list<integer>> = [
  Aggregate {
    source: Call {
      contract: pair[0],
      signature: "function balanceOf(address) returns (uint256)",
      params: tuple(pair[1])
    },
    blocks: numBlocks
  }
  for pair in monitoredPairsA
];

source balancesSeriesB: list<list<integer>> = [
  Aggregate {
    source: Call {
      contract: pair[0],
      signature: "function balanceOf(address) returns (uint256)",
      params: tuple(pair[1])
    },
    blocks: numBlocks
  }
  for pair in monitoredPairsB
];

// First and last samples per series
source firstBalancesA: list<integer> = [ series[0] for series in balancesSeriesA ];
source lastBalancesA: list<integer> = [ series[Len { sequence: series } - 1] for series in balancesSeriesA ];
source firstBalancesB: list<integer> = [ series[0] for series in balancesSeriesB ];
source lastBalancesB: list<integer> = [ series[Len { sequence: series } - 1] for series in balancesSeriesB ];

// Percentage difference per pair
source percentageDropsA: list<integer> = [
  PercentageDiff { before: firstBalancesA[i], after: lastBalancesA[i] }
  for i in Range { start: 0, stop: topN }
];

source percentageDropsB: list<integer> = [
  PercentageDiff { before: firstBalancesB[i], after: lastBalancesB[i] }
  for i in Range { start: 0, stop: topN }
];

// Indices where direction is a drop (last < first)
source dropIndicesA: list<integer> = [
  i
  for i in Range { start: 0, stop: topN }
  if lastBalancesA[i] < firstBalancesA[i]
];

source dropIndicesB: list<integer> = [
  i
  for i in Range { start: 0, stop: topN }
  if lastBalancesB[i] < firstBalancesB[i]
];

// Pairs with drop exceeding threshold
source anomalousPairsA: list<tuple<address, address>> = [
  monitoredPairsA[i]
  for i in dropIndicesA
  if percentageDropsA[i] >= dropThreshold
];

source anomalousPairsB: list<tuple<address, address>> = [
  monitoredPairsB[i]
  for i in dropIndicesB
  if percentageDropsB[i] >= dropThreshold
];

rule {
  description: "TVL anomaly: large drop detected for pairs $anomalousPairsA and $anomalousPairsB",
  condition: (Len { sequence: anomalousPairsA } + Len { sequence: anomalousPairsB }) == 0
};
