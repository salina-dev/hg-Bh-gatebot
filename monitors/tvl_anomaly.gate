// TVL Anomaly â€“ single pair 

use Call, Aggregate, PercentageDiff, Len from hexagate;

// Single pair to monitor; tokens auto-derived from the pair
source pair: address = 0x64D05ECC2cDc3e80D45BD1b25b0e8A7f7bf15cFc; // USDt/BLACK pair of Blackhole (0xcd94a87696fac69edae3a70fe5725307ae1c43f6)
source numBlocks: integer = 120;   // rolling window
source dropThreshold: integer = 10; // percent

// Derive token0 and token1 from the pair
source token0: address = Call { contract: pair, signature: "function token0() view returns (address)" };
source token1: address = Call { contract: pair, signature: "function token1() view returns (address)" };

// Aggregate token0 balance in the pair
source balanceSeries0: list<integer> = Aggregate {
  source: Call {
    contract: token0,
    signature: "function balanceOf(address) returns (uint256)",
    params: tuple(pair)
  },
  blocks: numBlocks
};

// Aggregate token1 balance in the pair
source balanceSeries1: list<integer> = Aggregate {
  source: Call {
    contract: token1,
    signature: "function balanceOf(address) returns (uint256)",
    params: tuple(pair)
  },
  blocks: numBlocks
};

// First/last for each
source first0: integer = balanceSeries0[0];
source last0: integer = balanceSeries0[Len { sequence: balanceSeries0 } - 1];
source first1: integer = balanceSeries1[0];
source last1: integer = balanceSeries1[Len { sequence: balanceSeries1 } - 1];

// Percent drops
source dropPct0: integer = PercentageDiff { before: first0, after: last0 };
source dropPct1: integer = PercentageDiff { before: first1, after: last1 };

// Rules: alert if either token shows a drop >= threshold
rule {
  description: "TVL anomaly (token0): drop >= ${dropThreshold}% on pair $pair",
  condition: (last0 >= first0) ? true : dropPct0 < dropThreshold
};

rule {
  description: "TVL anomaly (token1): drop >= ${dropThreshold}% on pair $pair",
  condition: (last1 >= first1) ? true : dropPct1 < dropThreshold
};
